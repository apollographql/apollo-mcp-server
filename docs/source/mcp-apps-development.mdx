---
title: MCP App Development
subtitle: Key concepts when developing MCP Apps
---

This document explains the core concepts of developing an MCP app using React, Apollo Client, and Apollo MCP Server.

If you are using the [Apollo AI Apps Template](https://github.com/apollographql/ai-apps-template) to follow along, much of the following code is provided for you. This guide walks through the critical areas of developing an MCP application for your own understanding.

## Get started

If you have experience developing with Apollo Client, you already know most of what you need to know to develop with MCP Apps, which uses the `@apollo/client-ai-apps` package to manage GraphQL operations. However, this guide doesn't provide a comprehensive explanation of Apollo Client. To learn about it, go to the [Apollo Client documentation](../react).

### Initialize Apollo Client

Initialize an instance of `ApolloClient` from the `@apollo/client-ai-apps` package. The `ApolloClient` constructor needs at least an instance of `ApolloCache` (typically `InMemoryCache`) and the [manifest file](./mcp-apps-reference#manifest-file).

<Caution>

Make sure you import `ApolloClient` from the `@apollo/client-ai-apps` package, not the core `@apollo/client` repository. The `ApolloClient` class from `@apollo/client-ai-apps` is for integrating with the MCP Apps environment.

</Caution>

```ts
// src/main.tsx
import { InMemoryCache } from "@apollo/client";
import { ApolloClient, ApplicationManifest } from "@apollo/client-ai-apps";
// Note the manifest is written to the root of the app
import manifest from "../.application-manifest.json";

// You may also provide other options that the core ApolloClient accepts
const client = new ApolloClient({
  cache: new InMemoryCache(),
  manifest: manifest as ApplicationManifest,
});
```

<Note>

Unlike the `ApolloClient` class from the core `@apollo/client` package, the `ApolloClient` class from `@apollo/client-ai-apps` doesn't require a configured `link`. By default, the class uses `ToolCallLink`, which executes GraphQL queries through MCP tools. <br/><br/>

You can provide a custom link chain to grant additional capabilities to `ApolloClient`; however, your terminating link needs to be a `ToolCallLink`.

</Note>

### Provide your client to `ApolloProvider`

Once you have a `client` instance, provide that client to `ApolloProvider`. Like `ApolloClient`, you need to use the `ApolloProvider` component exported from the `@apollo/client-ai-apps` package. This implementation is responsible for initializing the client with MCP Server.

```tsx
import { ApolloProvider } from "@apollo/client-ai-apps/react";

createRoot(document.getElementById("root")!).render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
);
```

#### Show a loading fallback during initialization

We can leverage React's [`Suspense` component](https://react.dev/reference/react/Suspense) to show a loading fallback while the client is connecting to our MCP server. Wrap `ApolloProvider` with `Suspense`.

```tsx
import { Suspense } from "react";

createRoot(document.getElementById("root")!).render(
  <Suspense fallback={<LoadingFallback />}>
    <ApolloProvider client={client}>
      <App />
    </ApolloProvider>
  </Suspense>,
);
```

<Note>

You are not required to use a `Suspense` component to show a loading fallback. If a `Suspense` component is not provided, the screen will remain blank until the tool result is available from the application host.

</Note>

## Register an MCP tool

You register MCP tools by writing GraphQL queries combined with the `@tool` directive.

For example, if you want to define a query that gets the highest-rated products in a marketplace application, define a query called `TopProductsQuery` in your React component, then use the `useQuery` hook from `@apollo/client/react` to read the query data. To register the query as its own tool, use the `@tool` directive.

```tsx
import { gql, TypedDocumentNode } from "@apollo/client";
import { useQuery } from "@apollo/client/react";

// Note: These types should be generated using a tool like GraphQL Codegen.
// Avoid writing them by hand.
const TOP_PRODUCTS_QUERY: TypedDocumentNode<
  TopProductsQuery,
  TopProductsQueryVariables
> = gql`
  query TopProductsQuery
  @tool(
    name: "TopProducts"
    description: "Shows a list of the highest rated products."
  ) {
    topProducts {
      id
      title
      rating
      price
      thumbnail
    }
  }
`;

function App() {
  const { data, loading, error, dataState } = useQuery(TOP_PRODUCTS_QUERY);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error! {error.message}</div>;
  }

  return (
    <div>
      {data.topProducts.map((product) => (
        <Product key={product.id} product={product} />
      ))}
    </div>
  );
}
```

Now that the query is registered as a tool, you can run the app in ChatGPT or an MCP Apps-compatible host and prompt the LLM to show you the top products. They render using data fetched by MCP Server.

## Platform-specific modules

ChatGPT provides additional capabilities with ChatGPT-specific extensions available through `window.openai`. This presents a problem when developing applications that also target MCP Apps-compatible hosts which do not provide `window.openai`.

You can create platform-specific modules using an additional file extension that designates the module as a platform-specific module.

- `<module-name>.openai.ts(x)` - Code specific to a ChatGPT app
- `<module-name>.mcp.ts(x)` - Code specific to an MCP app

You import these files using the base name. For example, if you need to provide a ChatGPT-specific `Home` component, you write it as the following:

```tsx
import { Home } from "./Home";
```

<Caution>

If you create a platform-specific module, you will need to create a module for the other platform, otherwise you will get a build error when the source component tries to import the module. For example, if you create a `Home.openai.tsx` file, you will also need to create either a `Home.mcp.tsx` or `Home.tsx` file.

</Caution>

<Tip>

Make sure your TypeScript configuration configures these files. `@apollo/client-ai-apps` provides extendable TypeScript config that adds the necessary configuration to write these components.

</Tip>

<Note>

The `apolloClientAiApps` vite plugin needs to include `openai` as a target.

</Note>

## Configuring app targets

## TypeScript configuration
